<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      #oCanvas {
        border: 1px solid #000;
      }
    </style>
  </head>

  <body>
    <canvas id="oCanvas" width="500" height="400"></canvas>
    <script type="notjs" id="vertex">
        /*
         顶点着色器
        */
       attribute vec4 a_position;
       //uniform vec4 u_Translate;
      // uniform float Tx, Ty, Tz;
       // uniform float u_cosb,u_sinb;
       uniform mat4 u_rotateMetrix;
       void main() {
           // [0, 0.5, 1, 0]
           // gl_Position.x =  a_position.x * u_cosb - a_position.y * u_sinb;
           // gl_Position.y = a_position.x * u_sinb + a_position.y * u_cosb;
           // gl_Position.z = a_position.z;
           // gl_Position.w = a_position.w;
           gl_Position = u_rotateMetrix * a_position;
       }
    </script>
    <script type="notjs" id="fragment">
      /*
          片元着色器 ： 绘制颜色或者纹理的 —— 水彩的作用
      */
      precision mediump float;

      void main() {
          gl_FragColor = vec4(0, 0, 0, 1);
      }
    </script>
    <script>
      var canvas = document.getElementById('oCanvas');
      var gl = canvas.getContext('webgl');
      if (!gl) {
        console.log('浏览器不兼容webgl');
      }

      var vertex = document.getElementById('vertex').innerText;
      var fragment = document.getElementById('fragment').innerText;

      // 顶点着色器 gl.VERTEX_SHADER   片元着色器 gl.FRAGMENT_SHADER;
      function createShader(gl, type, source) {
        var shader = gl.createShader(type);
        //  添加数据源
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }
        console.log(gl.getShaderInfoLog(shader));
      }

      var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertex);
      var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragment);

      function createProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }
        console.log(gl.getProgramInfoLog(program));
      }
      var program = createProgram(gl, vertexShader, fragmentShader);
      gl.useProgram(program);

      gl.clearColor(0, 0, 0, 0.5);
      gl.clear(gl.COLOR_BUFFER_BIT);
      // 获取a_position 存储位置
      var a_position = gl.getAttribLocation(program, 'a_position');
      var u_rotateMetrix = gl.getUniformLocation(program, 'u_rotateMetrix');
      var rotateDeg = 0;

      window.onkeydown = function (e) {
        switch (e.keyCode) {
          case 38:
            rotateDeg += 1;
            break;
          case 37:
            console.log('===37');
            break;
          case 39:
            console.log('===39');
            break;
          case 40:
            rotateDeg -= 1;
            break;
          default:
            break;
        }
        draw();
      };
      draw();
      // var u_cosb = gl.getUniformLocation(program, "u_cosb");
      // var u_sinb = gl.getUniformLocation(program, 'u_sinb');

      // console.log(sinb, cosb)
      // gl.uniform1f(u_cosb, cosb);
      // gl.uniform1f(u_sinb, sinb);
      // var u_Translate = gl.getUniformLocation(program, 'u_Translate');
      z;
      // gl.uniform4f(u_Translate, 0.5, -1.0, 1.0, 0);
      function draw() {
        console.log(rotateDeg);
        var sinb = Math.sin((rotateDeg * Math.PI) / 180).toFixed(2);
        var cosb = Math.cos((rotateDeg * Math.PI) / 180).toFixed(2);
        gl.uniformMatrix4fv(
          u_rotateMetrix,
          false,
          new Float32Array([
            cosb,
            sinb,
            0,
            0,
            -sinb,
            cosb,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
          ])
        );
        var positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([
            0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5,
            0.0, 0.0, 0.5, 0.5, 0.0,
          ]),
          gl.STATIC_DRAW
        );

        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, true, 0, 0);
        gl.enableVertexAttribArray(a_position);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    </script>
  </body>
</html>
